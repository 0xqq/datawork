#===============================================================
#配置文件不是必须的，Quartz对配置项都是有默认值的，当需要自定义的时候，
#可以在classpath路径下放一个quartz.properties文件，Quartz的StdSchedulerFactory
#在启动时会自动加载该配置文件。
#===============================================================
#===============================================================
#配置主调度程序的属性
#===============================================================
top.dataworks.task.quartz.scheduler.instanceName:DMP-DATATASK-QUARTZ
#===============================================================
#配置插件
#===============================================================
#===============================================================
#配置线程池的属性
#线程池里的线程数，默认值是10，当执行任务会并发执行多个耗时任务时，要根据业务特点选择线程池的大小。
#===============================================================
top.dataworks.task.quartz.threadPool.class:SimpleThreadPool
#top.dataworks.task.quartz.threadPool.class: TaskExecutorThreadPool
top.dataworks.task.quartz.threadPool.threadCount:10
top.dataworks.task.quartz.threadPool.threadPriority:5
top.dataworks.task.quartz..threadPool.threadsInheritContextClassLoaderOfInitializingThread:true
#===============================================================
#配置JobStore的属性
#misfireThreshold:用来指定调度引擎设置触发器超时的"临界值"
#===============================================================
top.dataworks.task.quartz.jobStore.misfireThreshold:60000
top.dataworks.task.quartz.jobStore.class:RAMJobStore
top.dataworks.task.quartz.scheduler.batchTriggerAcquisitionMaxCount:10
#当检查某个Trigger应该触发时，默认每次只Acquire一个Trigger，（为什么要有Acquire的过程呢？是为了防止多线程访问的情况下，
#同一个Trigger被不同的线程多次触发）。尤其是使用JDBC JobStore时，一次Acquire就是一个update语句，尽可能一次性的多获取
#几个Trigger，一起触发，当定时器数量非常大的时候，这是个非常有效的优化。当定时器数量比较少时，触发不是极为频繁时，
#这个优化的意义就不大了。
#top.dataworks.task.quartz.scheduler.batchTriggerAcquisitionMaxCount:10
#===============================================================